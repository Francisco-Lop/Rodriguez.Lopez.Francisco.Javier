/* This is auto-generated C code from LDmicro. Do not edit this file! Go
   back to the LDmicro ladder diagram source for changes in the ladder logic, and make
   any C additions either in ladder.h or in additional .c or .h files linked
   against this one. */

/* You must provide ladder.h; there you must provide:
   a typedef for SWORD and ldBOOL, signed 16 bit and boolean types
   (probably typedef signed short SWORD; typedef unsigned char bool;)

   You must also provide implementations of all the I/O read/write
   either as inlines in the header file or in another source file. (The
   I/O functions are all declared extern.)

   See the generated source code (below) for function names. */

#include "ladder.h"
#include "ladder_SCR.h" // Copy this line into main project file where is function main().

/* Define EXTERN_EVERYTHING in ladder.h if you want all symbols extern.
   This could be useful to implement `magic variables,' so that for
   example when you write to the ladder variable duty_cycle, your PLC
   runtime can look at the C variable U_duty_cycle and use that to set
   the PWM duty cycle on the micro. That way you can add support for
   peripherals that LDmicro doesn't know about. */
#ifdef EXTERN_EVERYTHING
  #define STATIC
#else
  #define STATIC static
#endif

/* Ux_xxx symbols correspond to user-defined names. There is such a symbol
   for every internal relay, variable, timer, and so on in the ladder
   program. Ix_xxx symbols are internally generated. */
/* Ix_xxx
   Ux_xxx
    ^
    b means bool type
    i means int type */

STATIC ldBOOL Ib_rung_top = 0;
#ifndef USE_MACRO
  // LDmicro provide this function.
  ldBOOL Read_Ub_Xswitch1(void) {
    return PINB & (1<<PINB0);
  }
#endif

#ifndef USE_MACRO
  // LDmicro provide these functions.
  ldBOOL Read_Ub_Ytenue1(void) {
    return PORTD & (1<<PORTD2);
  }
  void Write_Ub_Ytenue1(ldBOOL b) {
    if(b)
      PORTD |= 1<<PORTD2;
    else
      PORTD &= ~(1<<PORTD2);
  }
  void Write1_Ub_Ytenue1(void) {
      PORTD |= 1<<PORTD2;
  }
  void Write0_Ub_Ytenue1(void) {
      PORTD &= ~(1<<PORTD2);
  }
#endif

#ifndef USE_MACRO
  // LDmicro provide this function.
  ldBOOL Read_Ub_Xswitch3(void) {
    return PINB & (1<<PINB4);
  }
#endif

#ifndef USE_MACRO
  // LDmicro provide these functions.
  ldBOOL Read_Ub_Ytenue2(void) {
    return PORTD & (1<<PORTD4);
  }
  void Write_Ub_Ytenue2(ldBOOL b) {
    if(b)
      PORTD |= 1<<PORTD4;
    else
      PORTD &= ~(1<<PORTD4);
  }
  void Write1_Ub_Ytenue2(void) {
      PORTD |= 1<<PORTD4;
  }
  void Write0_Ub_Ytenue2(void) {
      PORTD &= ~(1<<PORTD4);
  }
#endif


/* Call this function once per PLC cycle. You are responsible for calling
   it at the interval that you specified in the LDmicro MCU configuration when you
   generated this code. */
void PlcCycle(void) {
                
    // ======= START RUNG 1 =======
    LabelRung1:;
    Write_Ib_rung_top(1);
    // start series [
    // ELEM_CONTACTS
    if(!Read_Ub_Xswitch1()) {
        Write_Ib_rung_top(0);
    }
    // ELEM_COIL
    Write_Ub_Ytenue1(Read_Ib_rung_top());
    // ] finish series
    
    // ======= START RUNG 2 =======
    LabelRung2:;
    Write_Ib_rung_top(1);
    // start series [
    // ELEM_CONTACTS
    if(!Read_Ub_Xswitch3()) {
        Write_Ib_rung_top(0);
    }
    // ELEM_COIL
    Write_Ub_Ytenue2(Read_Ib_rung_top());
    // ] finish series
    LabelRung3:;
    // Latest INT_OP here
}

void setupPlc(void) {
    // Set up I/O pins direction, and drive the outputs low to start.
    DDRB = 0x00;
    PORTB = 0x11;
    DDRC = 0x00;
    PORTC = 0x00;
    DDRD = 0x14;
    PORTD = 0x00;

    // Turn on the pull-ups.
    #ifdef CCS_PIC_C
        port_b_pullups(true);
    #elif defined(HI_TECH_C)
        nRBPU = 0;
    #endif

  #ifdef USE_WDT
    // Watchdog on
    #ifdef __CODEVISIONAVR__
        #ifndef WDTCR
            #define WDTCR WDTCSR
        #endif
        #asm("wdr")
        WDTCR |= (1<<WDE) | (1<<WDP2) | (1<<WDP1) | (1<<WDP0);
    #elif defined(__GNUC__)
        wdt_reset();
        wdt_enable(WDTO_2S);
    #elif defined(CCS_PIC_C)
        setup_wdt(WDT_2304MS);
    #elif defined(HI_TECH_C)
        //WDTCON=1;
    #else
        // Watchdog Init is required. // You must provide this.
    #endif
  #endif

    // Initialize PLC cycle timer here.
    // Configure Timer 1
        TCCR1A = 0x00; // WGM11=0, WGM10=0
        TCCR1B = (1<<WGM12) | 4; // WGM13=0, WGM12=1
        // `the high byte must be written before the low byte
        OCR1AH = (624 >> 8) & 0xff;
        OCR1AL = 624  & 0xff;
}

void mainPlc(void) { // Call mainPlc() function in main() of your project.
    setupPlc();
    while(1) {
        // Test PLC cycle timer interval here.
        #ifndef TIFR
        #define TIFR TIFR1
        #endif
        while((TIFR & (1<<OCF1A)) == 0);
        TIFR |= 1<<OCF1A; // OCF1A can be cleared by writing a logic one to its bit location


        PlcCycle();
        // You can place your code here, if you don't generate C code from LDmicro again.
        // ...

      #ifdef USE_WDT
        // Watchdog reset
        #ifdef __CODEVISIONAVR__
            #asm("wdr")
        #elif defined(__GNUC__)
            wdt_reset();
        #elif defined(CCS_PIC_C)
            restart_wdt();
        #elif defined(HI_TECH_C)
            CLRWDT();
        #else
            // Watchdog Reset is required. // You must provide this.
        #endif
      #endif

    }
}

#ifdef __CODEVISIONAVR__
void main(void) { // You can use this as is.
    mainPlc();
    return;
}
#else
int main(void) { // You can use this as is.
    mainPlc();
    return 0;
}
#endif
